/***********************************************************************/
/*                                                                     */
/*  FILE        :tominaga2.c                                              */
/*  DATE        :Tue, Jun 30, 2015                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8SX/1658                                             */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/

                                 
#include "iodefine.h"
#include <stdio.h>
#include <math.h>
#include <mathf.h>

#define TIMER	1869		//timer
#define PUL_CYC	0x074D		//pulse cycle 1869
#define PUL_WID_MAX	0x00BB		//pulse width 90% 187
#define PUL_WID_C 1712*4 //0x06BC	//pulse Center 1724
#define PUL_WID_L 1741*4 //0x06D6 	//pulse Leftmax	1750
#define PUL_WID_R 1683*4 //0x06A1	//pulse Rightmax 1697

#define SET	0xFFFF		//initial count 65355

#define WHEEL_DIR 0.060
#define WHEEL_BASE 0.170
#define MACHINE_WIDTH 0.150
#define TREAD 0.115
#define DEF_GEER 54
#define ENC_GEER 50
#define MOTOR_GEER 60
#define FRONT_GEER 34
#define GAIN_P 0.8
#define GAIN_I 0.1 
#define MAX_STEER 23.0    // deg
#define MIN_STEER -23.0   //deg
#define SOURCE_VOL 8.38
#define M_PI 3.14


signed long diff_DC = 0;        // Diff of DC
signed long diff_sv = 0;        // Diff Servo
double delta_t = 0;

// for odometry
double odom_x;
double odom_y;
double odom_yaw;

// for control & odometry
double dist;
double left_seta;
double steer_ang;
double velocity;


//for main init
//volatile unsigned long i;	    //for loop
//unsigned long cnt_timer = 0;	//count timer
unsigned long cnt_DC = 0;		// DC Motor count
unsigned long oldcnt_DC= 0;		// 
unsigned long cnt_sv = 0;		// Servo count
unsigned long oldcnt_sv= 0;		// 
	
unsigned int old_tcnt = 0;      // 
unsigned int tcnt = 0;          //
	
unsigned int timer = 0;         // For timer
unsigned int old_timer = 0;     //
	
unsigned int loop_cnt = 0;


typedef struct point
{
	float x;
	float y;
	float yaw;
};

void odom()
{	
	// culculate rear angular	
	double ang = tan(steer_ang)/WHEEL_BASE;
	
	if(steer_ang == 0){
		odom_x += dist*cos(odom_yaw);
		odom_y += dist*sin(odom_yaw);
		odom_yaw += odom_yaw;
	} 
	else if(steer_ang != 0){
		odom_x = odom_x + (sin(odom_yaw+dist*ang) - sin(odom_yaw))/ang;
		odom_y = odom_y - (cos(odom_yaw+dist*ang) + cos(odom_yaw))/ang;
		odom_yaw = atan2(sin(odom_yaw+dist*ang),cos(odom_yaw+dist*ang));	
	}
	
}

void drive(double rear_speed, double steer)
{
	
	double steer_deg = steer * 180.0 / M_PI;
	double max_speed = (SOURCE_VOL/7.2)*196.0*(36.0/10.0)/60.0*((double)MOTOR_GEER/(double)DEF_GEER)*M_PI*(double)WHEEL_DIR;
	static double u_k = 0;
	static double u_k1 = 0;
	static double e_k = 0;
	static double e_k1 = 0;

	e_k = rear_speed - velocity;
	u_k = u_k1 + (GAIN_P + GAIN_I*delta_t)*e_k - GAIN_P*e_k1;
	
	// set the limit
	if(u_k > max_speed)
		u_k = max_speed;

	e_k1 = e_k;
	u_k1 = u_k;
	
	//TPU.TSTR.BYTE = 0x2E;  // for rear
	//TPU.TSTR.BYTE = 0x1E;  // for front
	
	
	// for front
	TPU5.TGRB = PUL_WID_L - (int)((((double)MAX_STEER-steer_deg)/(double)(MAX_STEER-MIN_STEER))*(double)(PUL_WID_L-PUL_WID_R));
	if(TPU5.TGRB > PUL_WID_L)
		TPU5.TGRB = PUL_WID_L;
	if(TPU5.TGRB < PUL_WID_R)
		TPU5.TGRB = PUL_WID_R;
		
	// for rear
	TPU4.TGRB = (int)(1869.0 * (1.0 - (rear_speed/max_speed))); 

	TPU.TSTR.BYTE = 0x3E;

}

void move(double linear, double angular)
{
	if(linear == 0)
		drive(linear, 0);
	else if(linear != 0)
		drive(linear, atan(WHEEL_BASE*angular/linear));
}


void moving2pose(double target_x, double target_y, double target_theta, double target_rad, double now_x, double now_y, double now_theta, int nowtarget)
{
	static double x_diff = 0.0;
	static double y_diff = 0.0;
	static const double k_rho = 2.0;
	static const double k_beta = -3.0;
	static const double k_alpha = -6.0;
	static int target = -1;
	static const double first_rho =0.0;
	static double rho_k = 0.0;
	static double alpha_k = 0.0;
	static double beta_k = 0.0;
	
	static double delta_LR = 0.0;
	static double delta_LL = 0.0;
	static double delta_LR_tmp = 0.0;
 	static double delta_LL_tmp = 0.0;
	static double L_sum = 0.0;
	
	
	x_diff = target_x - now_x;
	y_diff = target_y - now_y;
	
	rho_k = sqrt(pow(x_diff, 2) + pow(y_diff, 2));
	alpha_k = atan2(y_diff, x_diff) - now_theta;
	beta_k = -now_theta - alpha_k;
	
	delta_LR_tmp = k_rho * rho_k + MACHINE_WIDTH * (k_alpha * alpha_k + k_beta * beta_k);
	delta_LL_tmp = k_rho * rho_k - MACHINE_WIDTH * (k_alpha * alpha_k + k_beta * beta_k);
	L_sum = delta_LR_tmp + delta_LL_tmp;
	
	delta_LR = target_rad * delta_LR_tmp / L_sum;
	delta_LL = target_rad * delta_LL_tmp / L_sum;
	
	//‚±‚±‚ç‚Å“®ì‚ð‘‚«‚½‚¢	
}


void TPU_init (void)
{
	
	///////////////////////////////////////////////
	// LED init
	///////////////////////////////////////////////
	PM.DDR = 0x08;             // decide LED pin
	PM.DR.BIT.B3 = 0;          // ouput=0 (LED ON)  
	
	///////////////////////////////////////////////
	// Motor DIR init
	///////////////////////////////////////////////
	PH.DDR = 0x01;             // PH.DDR to output
	PH.DR.BIT.B0 = 1;          // No 0 pin = 1 (HIGH)
	
	///////////////////////////////////////////////
	
	
	MSTP.CRA.BIT._TPUL = 0; 	// È“d—Íƒ‚[ƒh‰ðœ
	TPU.TSTR.BYTE = 0x00; 		// TPU timer (16bit timer) stop
	
	SCKCR.WORD = 0x0232;		// clock init
	
	///////////////////////////////////////////////
	// All Encoder's init
	///////////////////////////////////////////////
	P1.ICR.BYTE |= 0xF0;		// set encoder pin input
	PFC.PFCR6.BYTE |= 0x08;		// encoder pin init
	
	///////////////////////////////////////////////
	// DC Motor Encoder init
	///////////////////////////////////////////////
	TPU1.TMDR.BYTE = 0x00;		// init
	TPU1.TMDR.BYTE |= 0x04;		//phase factor mode
	
	///////////////////////////////////////////////
	// Servo Encoder init
	///////////////////////////////////////////////
	TPU2.TMDR.BYTE = 0x00;
	TPU2.TMDR.BYTE |= 0x04;		//phase factor mode
	
	///////////////////////////////////////////////
	// Interrupt timer init
	///////////////////////////////////////////////
	TPU3.TCR.BYTE = 0x23; 		// P 6MHz/64 = 93750Hz	
	TPU3.TMDR.BIT.MD = 0;		// 
	TPU3.TIOR.BIT.IOA = 1;		// initial 0, out 0	TCNTclear
	TPU3.TGRA = TIMER;			// set pulse cycle
	
	///////////////////////////////////////////////
	// DC Motor PWM init
	///////////////////////////////////////////////
	TPU4.TCR.BYTE = 0x23; 		//P 24MHz/64 = 375000Hz	
	TPU4.TMDR.BIT.MD = 2;		//PWM mode 1
	TPU4.TIOR.BIT.IOA = 1;		//initial 0, out 0	TCNTclear
	TPU4.TIOR.BIT.IOB = 2;		//initial 0, out 1
	TPU4.TGRA = PUL_CYC;		//set pulse cycle
	TPU4.TGRB = 800*(8.6 / 8.4); //PUL_WID_MAX	//set center

	
	//////////////////////////////////////////////
	// Servo Motor init
	//////////////////////////////////////////////
	TPU5.TCR.BYTE = 0x22; 		//P 24MHz/64 = 375000Hz	
	TPU5.TMDR.BIT.MD = 2;		//PWM mode 1
	TPU5.TIOR.BIT.IOA = 1;		//initial 0, out 0	TCNTclear
	TPU5.TIOR.BIT.IOB = 2;		//initial 0, out 1
	TPU5.TGRA = 7476;		//set pulse cycle
	TPU5.TGRB = PUL_WID_C;		//set pulse width
}

void wait (int n)
{
	
	int count = 0;
	long timernew = 0;
	long timerold = 0;
	TPU3.TCNT=0;
	while(count < 1 * n)
	{
		timernew = TPU3.TCNT;
		if(timernew == TIMER-1 && timernew != timerold)
		{
			count ++;
			TPU3.TCNT=0;
		}
		timerold = timernew;
	}
}

void Wait (int n)
{
	
	int count = 0;
	long timernew = 0;
	long timerold = 0;
	TPU3.TCNT=0;
	while(count < 1 * n)
	{
		timernew = TPU3.TCNT;
		if(timernew == (TIMER/4)-1 && timernew != timerold)
		{
			count ++;
			TPU3.TCNT=0;
		}
		timerold = timernew;
	}
}

void LED(int t){
	int i;
	for( i=1;i<=t;i++){
		PM.DR.BIT.B3 = 0;
		Wait(2);
		PM.DR.BIT.B3 = 1;
		Wait(2);
	}
}

	/////////////////////////////////////////////////////////////////////////////
	double DC_sum = 0;
	long DC_cnt = 0;
	long DC_old = 0;
	double DC_diff = 0;
	double DC_dist = 0;
	int DC_rot = 0;	//moter rotation
	double servo_pre = 0;
	double enc_pre = 0;
	double enc_er = 0;
	double enc_er1 = 0;
	double enc_er2 = 0;
	long er_sum = 0;
	double Kp = 0.407;//0.407
	double Ki = 1.8;//1.555
	double Kd = 0.000535;//0.000535
	long DC_bool = 0;
	long enc_l;
	long enc_r=0;
	long enc_c;
	double ser_cnt=0;
	//////////////////////DC_PI
	double DC_culc = 0;
	double DC_pre = 0;
	double DC_er = 0;
	double DC_er1 = 0;
	float Kpd = 1.5;
	float Kid = 7.0;
	
	////////////////////////////////////////////////////////////////////////////////

void DC_PI(int goal,long diff){
	
	
	
	DC_pre = TPU4.TGRB;
	DC_er1 = DC_er;
	DC_er = goal - diff;
	
	
	
	DC_culc = DC_pre - (Kpd + 0.04 * Kid)*DC_er + (Kpd * DC_er1);
	
	//pulse limitter
	if(DC_culc < 200){
		DC_culc = 200;
	}
	else if(DC_culc > 1700){
		DC_culc = 1700;
	}
	
	TPU4.TGRB = DC_culc;
	
	//if(diff < goal +10 && diff > goal -10){
	//	LED(2);
	//}	
	
}


void distance (double n , int i){
	enc_er = 0;
	enc_er1 = 0;
	enc_er2 = 0;
	er_sum = 0;

	DC_er = 0;
	DC_er1 = 0;
	DC_old = 65535;
	
	TPU1.TCNT = 65535;
	
//	TPU5.TGRB += (i - TPU2.TCNT)/3;
//	wait(1);
//	DC_pre = TPU5.TGRB;
	while( TPU1.TCNT > n){
		servo_pre = TPU5.TGRB;
	//	DC_cnt = 65535-TPU1.TCNT;
	/*	if(TPU2.TCNT != i){
			TPU5.TGRB = PUL_WID_L-(enc_l-i)*(PUL_WID_L-PUL_WID_R)/(enc_l-enc_r) ;
			wait(1);
		}*/
		//wait(10);
		enc_pre = TPU2.TCNT;
		enc_er2 = enc_er1;
		enc_er1 = enc_er;
		enc_er = i - enc_pre;
		er_sum += enc_er;
		
		
		

		
		TPU5.TGRB = servo_pre + (Kp + 0.04 * Ki + (Kd / 0.04))*enc_er - (Kp * enc_er1 + 2*(Kd / 0.04)) + (Kd / 0.04) * enc_er2 ;
		//TPU5.TGRB +=1;
		
		//pulse limitter
		if(TPU5.TGRB > PUL_WID_L){
			TPU5.TGRB = PUL_WID_L;	
		}
		else if(TPU5.TGRB < PUL_WID_R){
			TPU5.TGRB = PUL_WID_R;
		}
			
			
	//	if(enc_er < 3 && enc_er > -3){
	//		LED(1);
	//	}	
		
		
		DC_cnt = TPU1.TCNT;
		DC_diff = DC_old - DC_cnt;
		
		
		
		//DC_PI(200 , DC_diff);
		
		Wait(2);
		
		
		/*
		if(TPU2.TCNT < i ){
			TPU5.TGRB = DC_pre + Kp*1 + Ki*60*4*( i - TPU2.TCNT )/230;
			
			//TPU5.TGRB -=1;
			wait(1);
		}
		
		*/
		//wait(1);
			//	wait(10);
	/*	if( DC_diff < 1000){
			LED(1);
			//rot_cnt ++;
			//TPU4.TGRB = 187;			
		}*/
	/*	if(DC_cnt - DC_old < 0){				//fllow process
			LED(1);						//
			DC_diff = 65535 - DC_old + DC_cnt;//
		}*/								//
	//	if(DC_cnt - DC_old > 0){				//
	//		DC_diff = DC_cnt - DC_old;			//
	//	}								//
	/*	DC_diff = DC_cnt - DC_old;
		DC_sum += DC_diff;	
		DC_rot =  DC_sum * (50.0/53.0) / 2000.0;

	
		DC_dist = DC_sum * (50.0/53.0) * 0.202 / 2000.0; // raw distance calculated from rear encoder
		
		//rot_cnt ++;
		
		if( TPU1.TCNT > 65535 ){
			//LED(1);
			rot_cnt ++;
			//break;
			//TPU4.TGRB = 187;			
		}*/
	
		DC_old = DC_cnt;
		//DC_pre = TPU5.TGRB;
	}

	
}
	
int i;
	
void main ( void )
{	

	
	//unsigned short timer = 0;
	//unsigned short old_timer = 0;
	
	TPU_init();
	//PM.DR.BIT.B3 = 1;
	
	TPU2.TCNT = 0;        // Servo encoder init
	TPU1.TCNT = 50000;      // DCMotor encoder init
	PM.DR.BIT.B3 = 1;	//LED OFF

	
	TPU.TSTR.BYTE = 0x2E;  // start the timer for servo
	
	TPU5.TGRB = PUL_WID_L;
	wait(40);
	TPU5.TGRB = PUL_WID_R;	//initialize servoR
	wait(80);				//
	TPU2.TCNT = 0;			//

	TPU5.TGRB = PUL_WID_L;	//initialize servoL
	wait(80);				//
	enc_l = TPU2.TCNT;		//
	
	enc_c = enc_l/2;	//culculate servo senter
	TPU5.TGRB = PUL_WID_C;
	wait(80);
	
/*	
	TPU5.TGRB = 1708 * 4;
	wait(80);
	LED(1);
	TPU5.TGRB = 1715 * 4;
	wait(80);
	LED(1);
	TPU5.TGRB = 1707 * 4;
	wait(80);
	LED(1);
	TPU5.TGRB = 1720 * 4;
	wait(80);
	LED(1);
	TPU5.TGRB = 1700 * 4;
	wait(80);
	LED(1);
	TPU5.TGRB = 1725 * 4;
	wait(80);
	LED(1);
*/	
	

	//LED(1);	
	/*
	for(i=0;i<enc_c/10;i++){
		LED(1);
		wait(30);
	}*/
		

/*	if(enc_c > 100){
		LED(1);
	}else if(enc_c > 70){
		LED(2);
	}*/
	
	//while(TPU2.TCNT != enc_c){	//initialize center
	//while(TPU2.TCNT <= enc_c  || TPU2.TCNT >= enc_c +6){	
	//while(1){
	//		TPU5.TGRB = PUL_WID_L-(enc_l-enc_c - 3)*(PUL_WID_L-PUL_WID_R)/(enc_l-enc_r) ;	
				
	//	LED(1);
	/*	if(TPU2.TCNT < enc_c ){
			TPU5.TGRB +=1;	
			Wait(1);
		}else if(TPU2.TCNT > enc_c ){
			TPU5.TGRB -=1;
			Wait(1);
		}
	*/
	
	//DC_pre = TPU5.TGRB;

	
	
	LED(1);
//	TPU5.TGRB = 1709 * 4 + 2;
	
	
//	TPU5.TGRB = 1718;
	wait(150);
//	LED(1);
	TPU.TSTR.BYTE = 0x3E;	// start the timer for all
	
	/*
	DC_er = 0;
	DC_er1 = 0;
	DC_old = 65535;
	//DC_cnt = TPU1.TCNT;
	
	TPU1.TCNT = 65535;
	
	while(1){
		DC_cnt = TPU1.TCNT;
		DC_diff = DC_old - DC_cnt;
		DC_old = DC_cnt;
		
		if(TPU1.TCNT < 10000){
			DC_old = 65535 + DC_cnt - TPU1.TCNT;
			
			TPU1.TCNT = 65535;
			//LED(1);
			
		}		
		
		DC_PI(80 , DC_diff);
		
		
		
		

		Wait(1);
	}
	*/


/*
	while(1){
		TPU5.TGRB = 1725 * 4 ;
	}
*/
//	wait(50);
//	TPU4.TGRB = 700;
//	TPU1.TCNT = 65535;  
//	wait(1);
//	DC_cnt = -TPU1.TCNT;
//	TPU5.TGRB = 1709 * 4 + 2;
	distance(57000 , enc_c - 4 );
	distance(36500 , enc_c +12 );//3800
//	LED(1);
//	TPU5.TGRB = PUL_WID_L;
//	TPU5.TGRB = PUL_WID_L;
//	TPU5.TGRB = 1730 * 4    ;
	distance(26100, enc_c + 70);
//	LED(1);
//	TPU5.TGRB = PUL_WID_L;
//	TPU5.TGRB = 1709 * 4 + 2;
	distance(56800, enc_c -6 );
//	LED(1);
//	TPU5.TGRB = 1728 * 4 ;
	distance(49000, enc_c + 40);
//	LED(1);
//	TPU5.TGRB = 1709 * 4 ;
	distance(3000, enc_c + 19); //18

//	TPU5.TGRB = 1713 * 4;
	distance(39000, enc_c + 13); //14
//	LED(1
//	TPU5.TGRB = 1715 * 4;
	distance(30000, enc_c + 18);//23
//	LED(1);
//	TPU5.TGRB = 1727 * 4 + 2;


	distance(40000, enc_c + 10);
//	LED(1);// 3
//	TPU5.TGRB = 1712 * 4;
	distance(44000, enc_c + 28); //27
//	TPU5.TGRB = 1722 );* 4 + 2;
	distance(32400, enc_c );//29400
//	TPU5.TGRB = 1711 * 4;
	distance(45500, enc_c + 80);
		
	
//	TPU5.TGRB = PUL_WID_R;
	distance(58000, enc_c - 80);
	distance(34000, enc_c );

	distance(56500, enc_c -80);
	distance(34000, enc_c );
	distance(54000, enc_c -80);
	distance(29000, enc_c );
	
	
	
	
	
//	TPU5.TGRB = PUL_WID_C;
//	Wait(1);
//	distance(12, enc_c,DC_cnt,DC_old);

/*
	
	while(1)
	{
			
			break;
			DC_cnt = -TPU1.TCNT;
			
			if(DC_cnt - DC_old < 0){				//fllow process
				DC_diff = 65535 - DC_old + DC_cnt;	//
			}										//
			if(DC_cnt - DC_old >= 0){				//
				DC_diff = DC_cnt - DC_old;			//
			}										//
			
			DC_sum += DC_diff;	
			DC_rot =  DC_sum * (50.0/54.0) / 2000.0;
	
			
			DC_dist = DC_sum * (50.0/54.0) * 0.202 / 2000.0; // raw distance calculated from rear encoder
		
			if(DC_rot == rot_cnt  ){
				LED(1);
				rot_cnt ++;
				//TPU4.TGRB = 187;			
			}
			if(enc_c < 180){
				LED(5);
				//TPU4.TGRB = 30;
				//TPU4.TGRA = 800;
			}
				//wait();
				//PM.DR.BIT.B3 = 1;
				//wait();
		
		
			if( DC_dist >= 2.3){
				DC_sum = 0;
				break;
				
				TPU.TSTR.BYTE = 0x00;
				TPU4.TIOR.BIT.IOA = 1;
				TPU4.TIOR.BIT.IOB = 2;
				TPU5.TIOR.BIT.IOA = 1;
				TPU5.TIOR.BIT.IOB = 2;
				while(1);
				
			}
		
		//	DC_old = DC_cnt;
		
	
	//} // while
	*/
	
	TPU.TSTR.BYTE = 0x00;
	TPU4.TIOR.BIT.IOA = 1;
	TPU4.TIOR.BIT.IOB = 2;
	TPU5.TIOR.BIT.IOA = 1;
	TPU5.TIOR.BIT.IOB = 2;
	while(1);
	
	
	
	TPU5.TGRB = PUL_WID_R;
/*	
	while(1){
		if(TPU2.TCNT < enc_r){
			TPU5.TGRB ++;	
		}else{
			TPU5.TGRB --;
		}
	
		if(DC_cnt - DC_old < 0){				//fllow process
			DC_diff = 65535 - DC_old + DC_cnt;	//
		}										//
		if(DC_cnt - DC_old >= 0){				//
			DC_diff = DC_cnt - DC_old;			//
		}										//
		
		DC_sum += DC_diff;	
		DC_rot =  DC_sum * (50.0/54.0) / 2000.0;

		DC_dist = DC_sum * (50.0/54.0) * 0.202 / 2000.0; // raw distance calculated from rear encoder
	
		if( DC_dist >= 3){
			DC_sum = 0;
			TPU.TSTR.BYTE = 0x00;
			TPU4.TIOR.BIT.IOA = 1;
			TPU4.TIOR.BIT.IOB = 2;
			TPU5.TIOR.BIT.IOA = 1;
			TPU5.TIOR.BIT.IOB = 2;
			while(1);
		}
	
	
		

	}
*/
	
}